"""Generate types and schemas from HTTP request/response bodies using quicktype.

Uses the quicktype CLI to generate TypeScript, Python, Go, and other type definitions
from JSON response bodies.
"""

import json
import shutil
import subprocess
from datetime import datetime
from pathlib import Path
from webtap.app import app
from webtap.commands._builders import success_response, error_response
from webtap.commands._code_generation import ensure_output_directory, prepare_generation_data
from webtap.commands._tips import get_mcp_description


mcp_desc = get_mcp_description("quicktype")

# Header template for generated files
HEADER_TEMPLATE = """Generated by WebTap from request {row_id}
Source: {url}
Method: {method}
Generated: {timestamp}

Do not edit manually."""

# Comment syntax per language
COMMENT_STYLES = {
    "TypeScript": "//",
    "Python": "#",
    "Go": "//",
    "Rust": "//",
    "Java": "//",
    "Kotlin": "//",
    "Swift": "//",
    "C#": "//",
    "C++": "//",
    "Dart": "//",
    "Ruby": "#",
    "JSON Schema": None,
}


def _run_quicktype(
    json_data: dict | list,
    output: str,
    type_name: str = None,  # pyright: ignore[reportArgumentType]
    just_types: bool = True,
    prefer_types: bool = True,
    options: dict = None,  # pyright: ignore[reportArgumentType]
) -> tuple[bool, str]:
    """Run quicktype CLI with given parameters.

    Returns:
        Tuple of (success: bool, error_message: str)
    """
    if not shutil.which("quicktype"):
        return False, "quicktype CLI not found. Install with: npm install -g quicktype"

    output_path = Path(output)
    ext = output_path.suffix.lower()

    cmd = ["quicktype", "-o", str(output), "--src-lang", "json", "--top-level", type_name]

    if just_types:
        cmd.append("--just-types")

    if ext in {".ts", ".tsx"} and prefer_types:
        cmd.append("--prefer-types")

    for key, val in (options or {}).items():
        flag = f"--{key.replace('_', '-')}"
        if val is True:
            cmd.append(flag)
        elif val is not False and val is not None:
            cmd.extend([flag, str(val)])

    try:
        subprocess.run(
            cmd,
            input=json.dumps(json_data, indent=2),
            capture_output=True,
            text=True,
            check=True,
            timeout=30,
        )
        return True, ""
    except subprocess.CalledProcessError as e:
        return False, f"quicktype failed: {e.stderr.strip() if e.stderr else str(e)}"
    except subprocess.TimeoutExpired:
        return False, "quicktype timed out (>30s)"
    except Exception as e:
        return False, f"Unexpected error: {str(e)}"


def _insert_header(row_id: int, har_entry: dict, output_path: Path, language: str) -> None:
    """Insert language-aware header comment into generated file.

    Args:
        row_id: HAR row ID for reference.
        har_entry: HAR entry with request metadata.
        output_path: Path to generated file.
        language: Target language (e.g., "TypeScript", "Python").
    """
    if not HEADER_TEMPLATE or language not in COMMENT_STYLES:
        return

    comment_prefix = COMMENT_STYLES[language]
    if not comment_prefix:
        return

    try:
        request = har_entry.get("request", {})
        metadata = {
            "row_id": row_id,
            "url": request.get("url", "N/A"),
            "method": request.get("method", "N/A"),
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }

        header_text = HEADER_TEMPLATE.format(**metadata)
        header_lines = [
            f"{comment_prefix} {line}" if line.strip() else comment_prefix for line in header_text.split("\n")
        ]
        header = "\n".join(header_lines)

        content = output_path.read_text()
        output_path.write_text(header + "\n\n" + content)
    except Exception:
        pass


@app.command(
    display="markdown",
    typer={"enabled": False},
    fastmcp={"type": "tool", "mime_type": "text/markdown", "description": mcp_desc or ""},
)
def quicktype(
    state,
    id: int,
    output: str,
    type_name: str,
    target: str,
    field: str = "response.content",
    json_path: str = None,  # pyright: ignore[reportArgumentType]
    expr: str = None,  # pyright: ignore[reportArgumentType]
    just_types: bool = True,
    prefer_types: bool = True,
    options: dict = None,  # pyright: ignore[reportArgumentType]
) -> dict:  # pyright: ignore[reportArgumentType]
    """Generate types/schemas from request or response body using quicktype CLI.

    Args:
        id: Row ID from network() output
        output: Output file path (extension determines language: .ts, .py, .go, etc.)
        type_name: Top-level type name (e.g., "User", "ApiResponse")
        field: Body to use - "response.content" (default) or "request.postData"
        json_path: Optional JSON path to extract nested data (e.g., "data[0]")
        expr: Optional Python expression to transform data (has 'body' variable)
        just_types: Generate only types, no serializers (default: True)
        prefer_types: Use 'type' instead of 'interface' for TypeScript (default: True)
        options: Additional quicktype flags as dict

    Examples:
        quicktype(5, "types/User.ts", "User")
        quicktype(5, "models/customer.py", "Customer")
        quicktype(5, "api.go", "ApiResponse")
        quicktype(5, "types.ts", "User", json_path="data[0]")
        quicktype(5, "types/Form.ts", "Form", field="request.postData")
        quicktype(5, "types.ts", "User", options={"readonly": True})

    Returns:
        Success message with generation details
    """
    data, har_entry, error = prepare_generation_data(state, id, target, field, json_path, expr)
    if error:
        return error

    output_path = ensure_output_directory(output)

    # Run quicktype
    success, error_msg = _run_quicktype(
        json_data=data,
        output=str(output_path),
        type_name=type_name,
        just_types=just_types,
        prefer_types=prefer_types,
        options=options,
    )

    if not success:
        return error_response(
            error_msg,
            suggestions=[
                "Check that quicktype is installed: npm install -g quicktype",
                "Verify the JSON structure is valid",
                "Try simplifying with json_path",
            ],
        )

    # Detect language and insert header
    ext = output_path.suffix.lower()
    lang_map = {
        ".ts": "TypeScript",
        ".tsx": "TypeScript",
        ".py": "Python",
        ".go": "Go",
        ".rs": "Rust",
        ".java": "Java",
        ".kt": "Kotlin",
        ".swift": "Swift",
        ".cs": "C#",
        ".cpp": "C++",
        ".dart": "Dart",
        ".rb": "Ruby",
        ".json": "JSON Schema",
    }
    language = lang_map.get(ext, "Unknown")

    _insert_header(id, har_entry, output_path, language)

    # Count lines
    try:
        file_content = output_path.read_text()
        line_count = len(file_content.splitlines())
    except Exception:
        line_count = "unknown"

    return success_response(
        "Types generated successfully",
        details={
            "Output": str(output_path),
            "Language": language,
            "Type Name": type_name,
            "Lines": line_count,
            "Size": f"{output_path.stat().st_size} bytes",
        },
    )


__all__ = ["quicktype"]
